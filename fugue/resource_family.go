package fugue

import (
	"context"

	"github.com/fugue/fugue-client/client/families"
	"github.com/fugue/fugue-client/models"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceFamily() *schema.Resource {
	return &schema.Resource{
		Description:   "`fugue_family` manages the code and configuration for a family in Fugue.",
		CreateContext: resourceFamilyCreate,
		ReadContext:   resourceFamilyRead,
		UpdateContext: resourceFamilyUpdate,
		DeleteContext: resourceFamilyDelete,
		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},
		Schema: map[string]*schema.Schema{
			"id": {
				Description: "The unique ID for this family as generated by Fugue.",
				Type:        schema.TypeString,
				Computed:    true,
			},
			"name": {
				Description: "The name of the family.",
				Type:        schema.TypeString,
				Required:    true,
			},
			"description": {
				Description: "The description of the family.",
				Type:        schema.TypeString,
				Required:    true,
			},
			"recommended": {
				Description: "Whether the family is recommended.",
				Type:        schema.TypeBool,
				Optional:    true,
			},
		},
	}
}

func resourceFamilyCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {

	var diags diag.Diagnostics
	client := m.(*Client)

	name := d.Get("name").(string)
	description := d.Get("description").(string)
	recommended := d.Get("recommended").(bool)

	params := families.NewCreateFamilyParams()
	params.Family = &models.CreateFamilyInput{
		Name:        name,
		Description: description,
		Recommended: &recommended,
	}

	var familyID string

	err := resource.RetryContext(context.Background(), EnvironmentRetryTimeout, func() *resource.RetryError {
		resp, err := client.Families.CreateFamily(params, client.Auth)
		if err != nil {
			switch err.(type) {
			case *families.CreateFamilyForbidden:
				return resource.NonRetryableError(err)
			case *families.CreateFamilyUnauthorized:
				return resource.NonRetryableError(err)
			default:
				return resource.RetryableError(err)
			}
		}
		familyID = resp.Payload.ID
		return nil
	})
	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId(familyID)
	resourceFamilyRead(ctx, d, m)
	return diags
}

func resourceFamilyRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {

	var diags diag.Diagnostics
	client := m.(*Client)

	params := families.NewGetFamilyParams()
	params.FamilyID = d.Id()

	var family *models.FamilyWithRules

	err := resource.RetryContext(context.Background(), EnvironmentRetryTimeout, func() *resource.RetryError {
		resp, err := client.Families.GetFamily(params, client.Auth)
		if err != nil {
			switch err.(type) {
			case *families.GetFamilyForbidden:
				return resource.NonRetryableError(err)
			case *families.GetFamilyUnauthorized:
				return resource.NonRetryableError(err)
			default:
				return resource.RetryableError(err)
			}
		}
		family = resp.Payload
		return nil
	})
	if err != nil {
		return diag.FromErr(err)
	}

	if err := d.Set("name", family.Name); err != nil {
		return diag.FromErr(err)
	}
	if err := d.Set("description", family.Description); err != nil {
		return diag.FromErr(err)
	}
	if err := d.Set("recommended", family.Recommended); err != nil {
		return diag.FromErr(err)
	}

	return diags
}

func resourceFamilyUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {

	client := m.(*Client)

	params := families.NewUpdateFamilyParams()
	params.FamilyID = d.Id()
	params.Family.Description = d.Get("description").(string)
	recommended := d.Get("recommended").(bool)
	params.Family.Recommended = &recommended

	err := resource.RetryContext(context.Background(), EnvironmentRetryTimeout, func() *resource.RetryError {
		_, err := client.Families.UpdateFamily(params, client.Auth)
		if err != nil {
			switch err.(type) {
			case *families.UpdateFamilyForbidden:
				return resource.NonRetryableError(err)
			case *families.UpdateFamilyUnauthorized:
				return resource.NonRetryableError(err)
			case *families.UpdateFamilyNotFound:
				return resource.NonRetryableError(err)
			default:
				return resource.RetryableError(err)
			}
		}
		return nil
	})
	if err != nil {
		return diag.FromErr(err)
	}

	return resourceFamilyRead(ctx, d, m)
}

func resourceFamilyDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {

	client := m.(*Client)

	params := families.NewDeleteFamilyParams()
	params.FamilyID = d.Id()

	err := resource.RetryContext(context.Background(), EnvironmentRetryTimeout, func() *resource.RetryError {
		_, err := client.Families.DeleteFamily(params, client.Auth)
		if err != nil {
			switch err.(type) {
			case *families.DeleteFamilyForbidden:
				return resource.NonRetryableError(err)
			case *families.DeleteFamilyUnauthorized:
				return resource.NonRetryableError(err)
			default:
				return resource.RetryableError(err)
			}
		}
		return nil
	})
	if err != nil {
		return diag.FromErr(err)
	}
	return nil
}
