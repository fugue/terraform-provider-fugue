package fugue

import (
	"context"
	"errors"

	"github.com/fugue/fugue-client/client/custom_rules"
	"github.com/fugue/fugue-client/models"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceRule() *schema.Resource {
	return &schema.Resource{
		Description:   "`fugue_rule` manages the code and configuration for a rule in Fugue.",
		CreateContext: resourceRuleCreate,
		ReadContext:   resourceRuleRead,
		UpdateContext: resourceRuleUpdate,
		DeleteContext: resourceRuleDelete,
		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},
		Schema: map[string]*schema.Schema{
			"id": {
				Description: "The unique ID for this rule as generated by Fugue.",
				Type:        schema.TypeString,
				Computed:    true,
			},
			"name": {
				Description: "The name of the rule.",
				Type:        schema.TypeString,
				Required:    true,
			},
			"source": {
				Description: "The source of this rule: FUGUE or CUSTOM.",
				Type:        schema.TypeString,
				Computed:    true,
			},
			"description": {
				Description: "A description of this rule.",
				Type:        schema.TypeString,
				Required:    true,
			},
			"cloud_provider": {
				Description: "Indicates which environment type this rule is intended to be used with. One of: AWS, AWS_GOVCLOUD, AZURE, or GOOGLE.",
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
			},
			"severity": {
				Description: "Severity of this rule: Informational, Low, Medium, High, or Critical.",
				Type:        schema.TypeString,
				Required:    true,
			},
			"resource_type": {
				Description: "The resource type evaluated by this rule. This may be a string like `AWS.S3.Bucket` or `MULTIPLE` to indicate that multiple types are evaluated.",
				Type:        schema.TypeString,
				Required:    true,
			},
			"rule_text": {
				Description: "The Rego code for the rule, as a string.",
				Type:        schema.TypeString,
				Required:    true,
			},
		},
	}
}

func resourceRuleCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {

	var diags diag.Diagnostics
	client := m.(*Client)

	name := d.Get("name").(string)
	description := d.Get("description").(string)
	provider := d.Get("cloud_provider").(string)
	severity := d.Get("severity").(string)
	resourceType := d.Get("resource_type").(string)
	ruleText := d.Get("rule_text").(string)

	params := custom_rules.NewCreateCustomRuleParams()
	params.Rule = &models.CreateCustomRuleInput{
		Name:         name,
		Description:  description,
		Provider:     provider,
		Severity:     severity,
		ResourceType: resourceType,
		RuleText:     ruleText,
	}

	var ruleID string

	err := resource.Retry(EnvironmentRetryTimeout, func() *resource.RetryError {
		resp, err := client.CustomRules.CreateCustomRule(params, client.Auth)
		if err != nil {
			switch err.(type) {
			case *custom_rules.CreateCustomRuleForbidden:
				return resource.NonRetryableError(err)
			case *custom_rules.CreateCustomRuleUnauthorized:
				return resource.NonRetryableError(err)
			default:
				return resource.RetryableError(err)
			}
		}
		ruleID = resp.Payload.ID
		return nil
	})
	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId(ruleID)
	resourceRuleRead(ctx, d, m)
	return diags
}

func resourceRuleRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {

	var diags diag.Diagnostics
	client := m.(*Client)

	params := custom_rules.NewGetCustomRuleParams()
	params.RuleID = d.Id()

	var rule *models.CustomRule

	err := resource.Retry(EnvironmentRetryTimeout, func() *resource.RetryError {
		resp, err := client.CustomRules.GetCustomRule(params, client.Auth)
		if err != nil {
			switch err.(type) {
			case *custom_rules.GetCustomRuleForbidden:
				return resource.NonRetryableError(err)
			case *custom_rules.GetCustomRuleUnauthorized:
				return resource.NonRetryableError(err)
			default:
				return resource.RetryableError(err)
			}
		}
		rule = resp.Payload
		return nil
	})

	// If the resource is not found, remove it from local terraform state
	target := &custom_rules.GetCustomRuleNotFound{}
	if errors.As(err, &target) {
		d.SetId("")
		return nil
	}

	if err != nil {
		return diag.FromErr(err)
	}

	if err := d.Set("name", rule.Name); err != nil {
		return diag.FromErr(err)
	}
	if err := d.Set("description", rule.Description); err != nil {
		return diag.FromErr(err)
	}
	if err := d.Set("source", rule.Source); err != nil {
		return diag.FromErr(err)
	}
	if err := d.Set("cloud_provider", rule.Provider); err != nil {
		return diag.FromErr(err)
	}
	if err := d.Set("resource_type", rule.ResourceType); err != nil {
		return diag.FromErr(err)
	}
	if err := d.Set("rule_text", rule.RuleText); err != nil {
		return diag.FromErr(err)
	}
	if err := d.Set("severity", rule.Severity); err != nil {
		return diag.FromErr(err)
	}

	return diags
}

func resourceRuleUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {

	client := m.(*Client)

	params := custom_rules.NewUpdateCustomRuleParams()
	params.RuleID = d.Id()
	params.Rule = &models.UpdateCustomRuleInput{}
	params.Rule.Name = d.Get("name").(string)
	params.Rule.Description = d.Get("description").(string)
	params.Rule.Severity = d.Get("severity").(string)
	params.Rule.ResourceType = d.Get("resource_type").(string)
	params.Rule.RuleText = d.Get("rule_text").(string)

	err := resource.Retry(EnvironmentRetryTimeout, func() *resource.RetryError {
		_, err := client.CustomRules.UpdateCustomRule(params, client.Auth)
		if err != nil {
			switch err.(type) {
			case *custom_rules.UpdateCustomRuleForbidden:
				return resource.NonRetryableError(err)
			case *custom_rules.UpdateCustomRuleUnauthorized:
				return resource.NonRetryableError(err)
			case *custom_rules.UpdateCustomRuleNotFound:
				return resource.NonRetryableError(err)
			default:
				return resource.RetryableError(err)
			}
		}
		return nil
	})
	if err != nil {
		return diag.FromErr(err)
	}

	return resourceRuleRead(ctx, d, m)
}

func resourceRuleDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {

	client := m.(*Client)

	params := custom_rules.NewDeleteCustomRuleParams()
	params.RuleID = d.Id()

	err := resource.Retry(EnvironmentRetryTimeout, func() *resource.RetryError {
		_, err := client.CustomRules.DeleteCustomRule(params, client.Auth)
		if err != nil {
			switch err.(type) {
			case *custom_rules.DeleteCustomRuleForbidden:
				return resource.NonRetryableError(err)
			case *custom_rules.DeleteCustomRuleUnauthorized:
				return resource.NonRetryableError(err)
			default:
				return resource.RetryableError(err)
			}
		}
		return nil
	})
	if err != nil {
		return diag.FromErr(err)
	}
	return nil
}
