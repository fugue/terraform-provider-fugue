package fugue

import (
	"context"
	"log"

	"github.com/fugue/fugue-client/client/notifications"
	"github.com/fugue/fugue-client/models"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceNotification() *schema.Resource {
	return &schema.Resource{
		Description:   "`fugue_notification` manages the code and configuration for a notification in Fugue.",
		CreateContext: resourceNotificationCreate,
		ReadContext:   resourceNotificationRead,
		UpdateContext: resourceNotificationUpdate,
		DeleteContext: resourceNotificationDelete,
		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},
		Schema: map[string]*schema.Schema{
			"id": {
				Description: "The ID for this notification as generated by Fugue.",
				Type:        schema.TypeString,
				Computed:    true,
			},
			"name": {
				Description: "The name of the notification.  Must be unique.",
				Type:        schema.TypeString,
				Required:    true,
			},
			"emails": {
				Description: "The e-mail addresses to be notified.",
				Type:        schema.TypeList,
				Required:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"environments": {
				Description: "The environments of the notification",
				Type:        schema.TypeList,
				Required:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"events": {
				Description: "The events of the notification",
				Type:        schema.TypeList,
				Required:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"topic_arn": {
				Description: "Whether the notification is recommended.",
				Type:        schema.TypeString,
				Optional:    true,
			},
		},
	}
}

func resourceNotificationCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	var diags diag.Diagnostics
	client := m.(*Client)

	name := d.Get("name").(string)
	emails := getStringSlice(d.Get("emails").([]interface{}))
	environments := getStringSlice(d.Get("environments").([]interface{}))
	events := getStringSlice(d.Get("events").([]interface{}))
	topicArn := d.Get("topic_arn").(string)

	params := notifications.NewCreateNotificationParams()
	params.Notification = &models.CreateNotificationInput{
		Name:         name,
		Emails:       emails,
		Environments: environments,
		Events:       events,
		TopicArn:     topicArn,
	}

	var notificationID string

	err := resource.RetryContext(context.Background(), EnvironmentRetryTimeout, func() *resource.RetryError {
		resp, err := client.Notifications.CreateNotification(params, client.Auth)
		if err != nil {
			switch err.(type) {
			case *notifications.CreateNotificationForbidden:
				return resource.NonRetryableError(err)
			case *notifications.CreateNotificationUnauthorized:
				return resource.NonRetryableError(err)
			default:
				return resource.NonRetryableError(err)
			}
		}
		notificationID = resp.Payload.NotificationID
		return nil
	})
	if err != nil {
		return diag.FromErr(err)
	}

	d.SetId(notificationID)
	resourceNotificationRead(ctx, d, m)
	return diags
}

func resourceNotificationGetById(ctx context.Context, d *schema.ResourceData, m interface{}, id string) (*models.Notification, diag.Diagnostics) {
	client := m.(*Client)

	var result *models.Notification

	err := resource.RetryContext(context.Background(), EnvironmentRetryTimeout, func() *resource.RetryError {
		params := notifications.NewListNotificationsParams()
		offset := int64(0)
		maxItems := int64(100)
		isTruncated := true

		params.Offset = &offset
		params.MaxItems = &maxItems

		for isTruncated {
			resp, err := client.Notifications.ListNotifications(params, client.Auth)
			if err != nil {
				log.Printf("[WARN] Get waiver error: %s", err.Error())
				switch err.(type) {
				case *notifications.ListNotificationsInternalServerError:
					return resource.RetryableError(err)
				case *notifications.ListNotificationsForbidden:
					return resource.RetryableError(err)
				case *notifications.ListNotificationsUnauthorized:
					return resource.RetryableError(err)
				default:
					return resource.NonRetryableError(err)
				}
			}

			for _, notification := range resp.Payload.Items {
				if notification.NotificationID == id {
					result = notification
					return nil
				}
			}

			isTruncated = resp.Payload.IsTruncated
			offset = resp.Payload.NextOffset
		}
		return nil
	})
	if err != nil {
		return nil, diag.FromErr(err)
	}

	return result, nil
}

func resourceNotificationRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {

	notification, diags := resourceNotificationGetById(ctx, d, m, d.Id())
	if diags != nil {
		return diags
	}

	if notification == nil {
		return diag.Errorf("Unable to locate notification with id '%s'.", d.Id())
	}

	if err := d.Set("name", notification.Name); err != nil {
		return diag.FromErr(err)
	}
	if err := d.Set("emails", notification.Emails); err != nil {
		return diag.FromErr(err)
	}
	if err := d.Set("environments", notification.Environments); err != nil {
		return diag.FromErr(err)
	}
	if err := d.Set("events", notification.Events); err != nil {
		return diag.FromErr(err)
	}
	if err := d.Set("topic_arn", notification.TopicArn); err != nil {
		return diag.FromErr(err)
	}

	return diags
}

func resourceNotificationUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {

	client := m.(*Client)

	params := notifications.NewUpdateNotificationParams()
	params.NotificationID = d.Id()
	params.Notification.Name = d.Get("name").(string)
	params.Notification.Emails = d.Get("emails").([]string)
	params.Notification.Environments = d.Get("environments").([]string)
	params.Notification.Events = d.Get("events").([]string)
	params.Notification.TopicArn = d.Get("topic_arn").(string)

	err := resource.RetryContext(context.Background(), EnvironmentRetryTimeout, func() *resource.RetryError {
		_, err := client.Notifications.UpdateNotification(params, client.Auth)
		if err != nil {
			switch err.(type) {
			case *notifications.UpdateNotificationForbidden:
				return resource.NonRetryableError(err)
			case *notifications.UpdateNotificationUnauthorized:
				return resource.NonRetryableError(err)
			case *notifications.UpdateNotificationNotFound:
				return resource.NonRetryableError(err)
			default:
				return resource.RetryableError(err)
			}
		}
		return nil
	})
	if err != nil {
		return diag.FromErr(err)
	}

	return resourceNotificationRead(ctx, d, m)
}

func resourceNotificationDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {

	client := m.(*Client)

	params := notifications.NewDeleteNotificationParams()
	params.NotificationID = d.Id()

	err := resource.RetryContext(context.Background(), EnvironmentRetryTimeout, func() *resource.RetryError {
		_, err := client.Notifications.DeleteNotification(params, client.Auth)
		if err != nil {
			switch err.(type) {
			case *notifications.DeleteNotificationForbidden:
				return resource.NonRetryableError(err)
			case *notifications.DeleteNotificationUnauthorized:
				return resource.NonRetryableError(err)
			default:
				return resource.RetryableError(err)
			}
		}
		return nil
	})
	if err != nil {
		return diag.FromErr(err)
	}
	return nil
}
